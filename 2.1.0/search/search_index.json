{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Convoke","text":"<p>A decentralized app configuration toolkit that tries to do things right.</p>"},{"location":"#installation","title":"Installation","text":"<p>With Pip:</p> <pre><code>pip install convoke\n</code></pre>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Tutorials</li> <li>API Reference</li> </ul>"},{"location":"reference/","title":"API Reference Index","text":"<ul> <li><code>convoke.configs</code>: application configuration tools</li> <li><code>convoke.bases</code>: decentralized apps</li> <li><code>convoke.signals</code>: async inter-base messages</li> <li><code>convoke.mountpoints</code>: a simple plugin system for bases</li> </ul>"},{"location":"reference/bases/","title":"<code>convoke.bases</code>","text":"<p>Decentralized module dependency declaration and initialization</p> <p>Bases provide a similar concept to Django's AppConfig, and act as a central place for each module to register important things like signal handlers and template context processors, without needing a global central object.</p> <p>A single HQ acts as the coordinator for a suite of Bases. At runtime, an application instantiates an HQ, providing a list of dependencies (dotted strings, similar to Django's <code>INSTALLED_APPS</code> setting). Each dependency is a dotted string to a module or package containing a Base subclass named <code>Main</code>. Bases may also declare their own dependencies.</p> <p>This system allows us to avoid module-level code dependencies that depend overly on import order and global state, and allows a better separation of initialization and execution.</p>"},{"location":"reference/bases/#convokebaseshq","title":"convoke.bases.HQ","text":"<p>The HQ is the special root Base.</p> <p>The HQ is directly instantiated by a client code entrypoint, rather than discovered by the dependency loader.</p> <pre><code>hq = HQ(config=MyConfig(), dependencies=['foo'])\n</code></pre> Source code in <code>src/convoke/bases.py</code> <pre><code>@dataclass\nclass HQ:\n    \"\"\"The HQ is the special root Base.\n\n    The HQ is directly instantiated by a client code entrypoint, rather than\n    discovered by the dependency loader.\n\n        hq = HQ(config=MyConfig(), dependencies=['foo'])\n    \"\"\"\n\n    config: BaseConfig = field(default_factory=BaseConfig, repr=False)\n\n    bases: dict[str, Base] = field(init=False, default_factory=dict, repr=False)\n    signal_receivers: dict[Type[Signal], set[Receiver]] = field(init=False, default_factory=lambda: defaultdict(set))\n    mountpoints: MountpointDict[Type[Mountpoint], Mountpoint] = field(init=False, default_factory=MountpointDict)\n\n    hq: HQ = field(init=False)\n\n    current_instance: ClassVar[ContextVar] = ContextVar(\"current_instance\")\n\n    def __post_init__(self):\n        self.hq = self\n        self.current_instance.set(self)\n\n    @classmethod\n    def get_current(cls):\n        \"\"\"Return the instance of HQ for the current context.\"\"\"\n        return cls.current_instance.get()\n\n    def reset(self):\n        \"\"\"Reset this HQ and its associated Bases.\n\n        Primarily, this re-establishes this instance as the current HQ\n        instance, and re-initializes bases.\n\n        \"\"\"\n        self.current_instance.set(self)\n        for base in self.bases.values():\n            base.reset()\n\n    def load_dependencies(self, dependencies: Sequence[str]):\n        \"\"\"Load peripheral Base dependencies.\n\n        :param Sequence[str] dependencies: a list of dotted paths to\n            modules/packages that contain a Base subclass named `Main`.\n        \"\"\"\n        load_dependencies(self, dependencies)\n        for base in self.bases.values():\n            base.ready()\n            logging.debug(f\"{base.__module__} reports ready\")\n\n    def connect_signal_receiver(self, signal_class: Type[Signal], receiver: Receiver):\n        \"\"\"Connect a receiver function to the given Signal subclass.\n\n        All connections are local to this HQ instance. Mostly used\n        internally via the `Base.responds(SignalSubclass)` decorator.\n\n        :param Type[Signal] signal_class: The Signal subclass to connect to.\n        :param Receiver receiver: a Callable that accepts a message of the type\n            defined on the Signal subclass.\n\n        \"\"\"\n        self.signal_receivers[signal_class].add(receiver)\n\n    def disconnect_signal_receiver(self, signal_class: Type[Signal], receiver: Receiver):\n        \"\"\"Disconnect a receiver function previously connected to the given Signal subclass.\n\n        :param Type[Signal] signal_class: The Signal subclass to disconnect from.\n        :param Receiver receiver: a previously-connected Callable.\n        \"\"\"\n        self.signal_receivers[signal_class].discard(receiver)\n\n    async def send_signal(self, signal_class: Type[Signal], msg):\n        \"\"\"Send a Message to all receivers of the given Signal subclass.\n\n        :param Type[Signal] signal_class: The Signal subclass to send\n        :param Any msg: An instance of signal_class.Message\n        \"\"\"\n        for receiver in self.signal_receivers[signal_class]:\n            try:\n                if is_async_callable(receiver):\n                    await receiver(msg)\n                else:\n                    receiver(msg)\n            except Exception:  # pragma: nocover\n                # It's important that we swallow the exception, log\n                # it, and soldier on. We don't need to cover this\n                # branch though.\n                logging.exception(\n                    f\"Exception occurred while sending {signal_class!r}:\\nReceiver {receiver!r}\\n Message: {msg!r}\"\n                )\n</code></pre>"},{"location":"reference/bases/#convoke.bases.HQ.connect_signal_receiver","title":"<code>connect_signal_receiver(signal_class, receiver)</code>","text":"<p>Connect a receiver function to the given Signal subclass.</p> <p>All connections are local to this HQ instance. Mostly used internally via the <code>Base.responds(SignalSubclass)</code> decorator.</p> <p>Parameters:</p> Name Type Description Default <code>signal_class</code> <code>Type[Signal]</code> <p>The Signal subclass to connect to.</p> required <code>receiver</code> <code>Receiver</code> <p>a Callable that accepts a message of the type defined on the Signal subclass.</p> required Source code in <code>src/convoke/bases.py</code> <pre><code>def connect_signal_receiver(self, signal_class: Type[Signal], receiver: Receiver):\n    \"\"\"Connect a receiver function to the given Signal subclass.\n\n    All connections are local to this HQ instance. Mostly used\n    internally via the `Base.responds(SignalSubclass)` decorator.\n\n    :param Type[Signal] signal_class: The Signal subclass to connect to.\n    :param Receiver receiver: a Callable that accepts a message of the type\n        defined on the Signal subclass.\n\n    \"\"\"\n    self.signal_receivers[signal_class].add(receiver)\n</code></pre>"},{"location":"reference/bases/#convoke.bases.HQ.disconnect_signal_receiver","title":"<code>disconnect_signal_receiver(signal_class, receiver)</code>","text":"<p>Disconnect a receiver function previously connected to the given Signal subclass.</p> <p>Parameters:</p> Name Type Description Default <code>signal_class</code> <code>Type[Signal]</code> <p>The Signal subclass to disconnect from.</p> required <code>receiver</code> <code>Receiver</code> <p>a previously-connected Callable.</p> required Source code in <code>src/convoke/bases.py</code> <pre><code>def disconnect_signal_receiver(self, signal_class: Type[Signal], receiver: Receiver):\n    \"\"\"Disconnect a receiver function previously connected to the given Signal subclass.\n\n    :param Type[Signal] signal_class: The Signal subclass to disconnect from.\n    :param Receiver receiver: a previously-connected Callable.\n    \"\"\"\n    self.signal_receivers[signal_class].discard(receiver)\n</code></pre>"},{"location":"reference/bases/#convoke.bases.HQ.get_current","title":"<code>get_current()</code>  <code>classmethod</code>","text":"<p>Return the instance of HQ for the current context.</p> Source code in <code>src/convoke/bases.py</code> <pre><code>@classmethod\ndef get_current(cls):\n    \"\"\"Return the instance of HQ for the current context.\"\"\"\n    return cls.current_instance.get()\n</code></pre>"},{"location":"reference/bases/#convoke.bases.HQ.load_dependencies","title":"<code>load_dependencies(dependencies)</code>","text":"<p>Load peripheral Base dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Sequence[str]</code> <p>a list of dotted paths to modules/packages that contain a Base subclass named <code>Main</code>.</p> required Source code in <code>src/convoke/bases.py</code> <pre><code>def load_dependencies(self, dependencies: Sequence[str]):\n    \"\"\"Load peripheral Base dependencies.\n\n    :param Sequence[str] dependencies: a list of dotted paths to\n        modules/packages that contain a Base subclass named `Main`.\n    \"\"\"\n    load_dependencies(self, dependencies)\n    for base in self.bases.values():\n        base.ready()\n        logging.debug(f\"{base.__module__} reports ready\")\n</code></pre>"},{"location":"reference/bases/#convoke.bases.HQ.reset","title":"<code>reset()</code>","text":"<p>Reset this HQ and its associated Bases.</p> <p>Primarily, this re-establishes this instance as the current HQ instance, and re-initializes bases.</p> Source code in <code>src/convoke/bases.py</code> <pre><code>def reset(self):\n    \"\"\"Reset this HQ and its associated Bases.\n\n    Primarily, this re-establishes this instance as the current HQ\n    instance, and re-initializes bases.\n\n    \"\"\"\n    self.current_instance.set(self)\n    for base in self.bases.values():\n        base.reset()\n</code></pre>"},{"location":"reference/bases/#convoke.bases.HQ.send_signal","title":"<code>send_signal(signal_class, msg)</code>  <code>async</code>","text":"<p>Send a Message to all receivers of the given Signal subclass.</p> <p>Parameters:</p> Name Type Description Default <code>signal_class</code> <code>Type[Signal]</code> <p>The Signal subclass to send</p> required <code>msg</code> <code>Any</code> <p>An instance of signal_class.Message</p> required Source code in <code>src/convoke/bases.py</code> <pre><code>async def send_signal(self, signal_class: Type[Signal], msg):\n    \"\"\"Send a Message to all receivers of the given Signal subclass.\n\n    :param Type[Signal] signal_class: The Signal subclass to send\n    :param Any msg: An instance of signal_class.Message\n    \"\"\"\n    for receiver in self.signal_receivers[signal_class]:\n        try:\n            if is_async_callable(receiver):\n                await receiver(msg)\n            else:\n                receiver(msg)\n        except Exception:  # pragma: nocover\n            # It's important that we swallow the exception, log\n            # it, and soldier on. We don't need to cover this\n            # branch though.\n            logging.exception(\n                f\"Exception occurred while sending {signal_class!r}:\\nReceiver {receiver!r}\\n Message: {msg!r}\"\n            )\n</code></pre>"},{"location":"reference/bases/#convokebasesbase","title":"convoke.bases.Base","text":"<p>A Base organizes an app within a Convoke project.</p> <p>For base discovery, an app should provide a subclass named <code>Main</code> in the app's primary module:</p> <pre><code>class Main(Base):\n    config_class: MyConfig = MyConfig\n\n    # Dependencies are dotted paths to modules containing a\n    # Main subclass:\n    dependencies = ['foo', 'foo.bar']\n</code></pre> <p>Base is similar in concept to Django's <code>AppConfig</code>.</p> Source code in <code>src/convoke/bases.py</code> <pre><code>class Base(metaclass=BaseMeta):\n    \"\"\"A Base organizes an app within a Convoke project.\n\n    For base discovery, an app should provide a subclass named `Main`\n    in the app's primary module:\n\n        class Main(Base):\n            config_class: MyConfig = MyConfig\n\n            # Dependencies are dotted paths to modules containing a\n            # Main subclass:\n            dependencies = ['foo', 'foo.bar']\n\n    Base is similar in concept to Django's `AppConfig`.\n    \"\"\"\n\n    hq: HQ\n\n    bases: dict[str, Base] = field(init=False, default_factory=dict, repr=False)\n\n    config: BaseConfig = field(init=False, repr=False)\n\n    dependencies: ClassVar[Sequence[str]] = ()\n    config_class: ClassVar[Type[BaseConfig]] = BaseConfig\n    current_instance: ClassVar[ContextVar]\n\n    def __init_subclass__(cls):\n        cls.current_instance = ContextVar(\"current_instance\")\n\n    def __post_init__(self):\n        self.reset()\n\n    def ready(self):\n        \"\"\"Make the base ready for action.\"\"\"\n        self.on_ready()\n\n    field = field\n    responds = responds\n\n    def reset(self):\n        \"\"\"Reset the base, reloading configuration and initialization.\"\"\"\n        self.config = self.config_class.from_config(self.hq.config)\n        self.on_init()\n        self._register_special_methods()\n        self.current_instance.set(self)\n\n    def on_init(self):\n        \"\"\"Subclass-overridable method to call at the end of initialization\"\"\"\n        pass\n\n    def on_ready(self):\n        \"\"\"Subclass-overridable method to call after all Bases ready\"\"\"\n        pass\n\n    @classmethod\n    def get_current(cls):\n        \"\"\"Return the current instance of this Base for the current context.\"\"\"\n        return cls.current_instance.get()\n\n    def _register_special_methods(self):\n        \"\"\"Look for and register specially-decorated Base methods.\"\"\"\n        # We need to inspect members of the class, not the instance,\n        # to avoid tripping over any descriptors before we're ready.\n        for name, func in inspect.getmembers(self.__class__, inspect.isfunction):\n            if inspect.ismethod(method := getattr(self, name)):\n                # Register signals\n                signals = getattr(func, \"__signals__\", ())\n                for signal in signals:\n                    self.hq.connect_signal_receiver(signal, method)\n\n                # Register mountpoints\n                mountpoints = getattr(method.__func__, \"__mountpoints__\", ())\n                for mountpoint in mountpoints:\n                    self.hq.mountpoints[mountpoint].mount(method)\n            else:  # pragma: nocover\n                pass\n</code></pre>"},{"location":"reference/bases/#convoke.bases.Base.get_current","title":"<code>get_current()</code>  <code>classmethod</code>","text":"<p>Return the current instance of this Base for the current context.</p> Source code in <code>src/convoke/bases.py</code> <pre><code>@classmethod\ndef get_current(cls):\n    \"\"\"Return the current instance of this Base for the current context.\"\"\"\n    return cls.current_instance.get()\n</code></pre>"},{"location":"reference/bases/#convoke.bases.Base.on_init","title":"<code>on_init()</code>","text":"<p>Subclass-overridable method to call at the end of initialization</p> Source code in <code>src/convoke/bases.py</code> <pre><code>def on_init(self):\n    \"\"\"Subclass-overridable method to call at the end of initialization\"\"\"\n    pass\n</code></pre>"},{"location":"reference/bases/#convoke.bases.Base.on_ready","title":"<code>on_ready()</code>","text":"<p>Subclass-overridable method to call after all Bases ready</p> Source code in <code>src/convoke/bases.py</code> <pre><code>def on_ready(self):\n    \"\"\"Subclass-overridable method to call after all Bases ready\"\"\"\n    pass\n</code></pre>"},{"location":"reference/bases/#convoke.bases.Base.ready","title":"<code>ready()</code>","text":"<p>Make the base ready for action.</p> Source code in <code>src/convoke/bases.py</code> <pre><code>def ready(self):\n    \"\"\"Make the base ready for action.\"\"\"\n    self.on_ready()\n</code></pre>"},{"location":"reference/bases/#convoke.bases.Base.reset","title":"<code>reset()</code>","text":"<p>Reset the base, reloading configuration and initialization.</p> Source code in <code>src/convoke/bases.py</code> <pre><code>def reset(self):\n    \"\"\"Reset the base, reloading configuration and initialization.\"\"\"\n    self.config = self.config_class.from_config(self.hq.config)\n    self.on_init()\n    self._register_special_methods()\n    self.current_instance.set(self)\n</code></pre>"},{"location":"reference/configs/","title":"<code>convoke.configs</code>","text":"<p>Tools for parsing configuration values from the environment</p>"},{"location":"reference/configs/#convokeconfigsenv_field","title":"convoke.configs.env_field","text":"<p>Define a field that pulls config values from the environment.</p> <p>Fields with missing defaults will be assumed to be required, and if missing will produce an error.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>the default value to use, if any, of the expected type. If this is omitted, the field will be required.</p> <code>MISSING</code> <code>doc</code> <code>str</code> <p>a docstring describing the use of the configuration value, used in generating .env files</p> <code>''</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def env_field(\n    *,\n    default=dc.MISSING,\n    init=True,\n    repr=True,\n    hash=None,\n    compare=True,\n    metadata=None,\n    kw_only=dc.MISSING,\n    doc=\"\",\n):\n    \"\"\"Define a field that pulls config values from the environment.\n\n    Fields with missing defaults will be assumed to be required, and if missing will produce an error.\n\n    :param Any default: the default value to use, if any, of the expected type. If this is omitted, the field will be required.\n    :param str doc: a docstring describing the use of the configuration value, used in generating .env files\n\n    \"\"\"\n    return ConfigField(default, init, repr, hash, compare, metadata, kw_only, doc)\n</code></pre>"},{"location":"reference/configs/#convokeconfigssecret","title":"convoke.configs.Secret","text":"<p>             Bases: <code>str</code></p> <p>A string value that should not be revealed in logs, tracebacks, etc.</p> Source code in <code>src/convoke/configs.py</code> <pre><code>class Secret(str):\n    \"\"\"A string value that should not be revealed in logs, tracebacks, etc.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        class_name = self.__class__.__name__\n        return f\"{class_name}('**********')\"\n</code></pre>"},{"location":"reference/configs/#convokeconfigsbaseconfig","title":"convoke.configs.BaseConfig","text":"<p>Base settings common to all configurations</p> Source code in <code>src/convoke/configs.py</code> <pre><code>class BaseConfig(metaclass=BaseConfigMeta):\n    \"\"\"Base settings common to all configurations\"\"\"\n\n    DEBUG: bool = env_field(default=False, doc=\"Development mode?\")\n    TESTING: bool = env_field(default=False, doc=\"Testing mode?\")\n\n    env_field = env_field\n\n    @classmethod\n    def from_config(cls: Type[T], config: \"BaseConfig\") -&gt; T:\n        \"\"\"Derive an instance of this config class from another configuration.\n\n        This is really only useful if the passed configuration has\n        overridden (non-environment-derived) values.\n\n        \"\"\"\n        valid_params = set(inspect.signature(cls).parameters)\n        kwargs = {k: v for k, v in dc.asdict(config).items() if k in valid_params}\n        return cls(**kwargs)\n\n    @classmethod\n    def gather_settings(cls) -&gt; dict:\n        \"\"\"Gather settings from all loaded configurations.\"\"\"\n        base = BaseConfig.report_settings()\n        base_settings = set(base[\"settings\"].keys())\n        all_settings = {f\"{BaseConfig.__module__}.{BaseConfig.__name__}\": base}\n        for config in cls.plugins_by_name.values():\n            settings = config.report_settings()\n            all_settings[f\"{config.__module__}.{config.__name__}\"] = {\n                \"doc\": settings[\"doc\"],\n                \"settings\": omit(settings[\"settings\"], base_settings),\n            }\n\n        return all_settings\n\n    @classmethod\n    def report_settings(cls) -&gt; dict:\n        \"\"\"Prepare a datastructure reporting on this configuration class's settings.\"\"\"\n        return {\n            \"doc\": format_object_docstring(cls),\n            \"settings\": {\n                fd.name: {\n                    \"type\": fd.type,\n                    \"default\": (\n                        UNDEFINED\n                        if (default := getattr(fd, \"__config_default__\", dc.MISSING)) is dc.MISSING\n                        else default\n                    ),\n                    \"doc\": getattr(fd, \"__doc__\", \"\"),\n                }\n                for fd in dc.fields(cls)\n            },\n        }\n\n    def __getitem__(self, name: str) -&gt; str:\n        if hasattr(self, name):\n            return getattr(self, name)\n\n        return os.environ[name]\n\n    def get(self, name: str, default: Any = UNDEFINED, caster: Union[Type, TUndefined] = UNDEFINED) -&gt; Any:\n        \"\"\"Return the named configuration environment value, optionally casting it as specified.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already the expected type.\n        :param Type caster: A type to cast the string value to, if any.\n        \"\"\"\n        if caster is UNDEFINED:\n            caster = identity\n        else:\n            caster = get_casting_type(name, caster)\n        try:\n            value = self[name]\n        except KeyError:\n            if default is UNDEFINED:\n                raise\n            else:\n                value = default\n\n        return caster(value)\n\n    def asdict(self, keys=()) -&gt; dict:\n        \"\"\"Return a dictionary with the defined settings\"\"\"\n        if keys:\n            return fn.project(dc.asdict(self), keys)\n        else:\n            return dc.asdict(self)\n\n    def get_tuple(\n        self, name: str, default: Union[tuple[Any], TUndefined] = UNDEFINED, caster: Type = tuple[str]\n    ) -&gt; tuple[Any]:\n        \"\"\"Return the named configuration environment value as a sequence, optionally casting internal values as specified.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already the expected type.\n        :param Type caster: A type to cast the internal string values to, if any.\n        \"\"\"\n        return self.get(name, default=default, caster=caster)\n\n    def as_secret(self, name: str, default: Secret = UNDEFINED) -&gt; Secret:\n        \"\"\"Return the named configuration environment value as a Secret string.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a Secret.\n        \"\"\"\n        return self.get(name, default=default, caster=Secret)\n\n    def as_secret_tuple(self, name: str, default: Union[tuple[Secret], TUndefined] = UNDEFINED) -&gt; tuple[Secret]:\n        \"\"\"Return the named configuration environment value as a sequence of Secret strings.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a tuple of Secrets.\n        \"\"\"\n        return self.get_tuple(name, default=default, caster=tuple[Secret])\n\n    def as_bool(self, name: str, default: Union[bool, TUndefined] = UNDEFINED) -&gt; bool:\n        \"\"\"Return the named configuration environment value as a boolean value.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a boolean.\n        \"\"\"\n        return self.get(name, default=default, caster=bool)\n\n    def as_bool_tuple(self, name: str, default: Union[tuple[bool], TUndefined] = UNDEFINED) -&gt; tuple[bool]:\n        \"\"\"Return the named configuration environment value as a tuple of boolean values.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a tuple of booleans.\n        \"\"\"\n        return self.get_tuple(name, default=default, caster=tuple[bool])\n\n    def as_int(self, name: str, default: Union[int, TUndefined] = UNDEFINED) -&gt; int:\n        \"\"\"Return the named configuration environment value as an int.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already an int.\n        \"\"\"\n        return self.get(name, default=default, caster=int)\n\n    def as_int_tuple(self, name: str, default: Union[tuple[int], TUndefined] = UNDEFINED) -&gt; tuple[int]:\n        \"\"\"Return the named configuration environment value as a tuple of ints.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a tuple of ints.\n        \"\"\"\n        return self.get_tuple(name, default=default, caster=tuple[int])\n\n    def as_float(self, name: str, default: Union[float, TUndefined] = UNDEFINED) -&gt; float:\n        \"\"\"Return the named configuration environment value as a float.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a float.\n        \"\"\"\n        return self.get(name, default=default, caster=float)\n\n    def as_float_tuple(self, name: str, default: Union[tuple[float], TUndefined] = UNDEFINED) -&gt; tuple[float]:\n        \"\"\"Return the named configuration environment value as a tuple of floats.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a tuple of floats.\n        \"\"\"\n        return self.get_tuple(name, default=default, caster=tuple[float])\n\n    def as_path(self, name: str, default: Union[Path, TUndefined] = UNDEFINED) -&gt; Path:\n        \"\"\"Return the named configuration environment value as a Path.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a Path.\n        \"\"\"\n        return self.get(name, default=default, caster=Path)\n\n    def as_path_tuple(self, name: str, default: Union[tuple[float], TUndefined] = UNDEFINED) -&gt; tuple[Path]:\n        \"\"\"Return the named configuration environment value as a tuple of Paths.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a tuple of Paths.\n        \"\"\"\n        return self.get(name, default=default, caster=tuple[Path])\n\n    def as_package_import(self, name: str, default: Union[Any, TUndefined] = UNDEFINED) -&gt; Any:\n        \"\"\"Return the named configuration environment value as an imported module.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a module.\n        \"\"\"\n        path = self.get(name, default=default)\n        return importlib.import_module(path)\n\n    def as_package_import_tuple(self, name: str, default: Union[tuple[Any], TUndefined] = UNDEFINED) -&gt; tuple[Any]:\n        \"\"\"Return the named configuration environment value as a tuple of imported modules.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a tuple of modules.\n        \"\"\"\n        paths = self.get_tuple(name, default=default)\n        return tuple(importlib.import_module(path) for path in paths)\n\n    def as_object_import(self, name: str, default: Union[Any, TUndefined] = UNDEFINED) -&gt; Any:\n        \"\"\"Return the named configuration environment value as an imported object.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already an object.\n        \"\"\"\n        path = self.get(name, default=default)\n        return import_object(path)\n\n    def as_object_import_tuple(self, name: str, default: Union[tuple[Any], TUndefined] = UNDEFINED):\n        \"\"\"Return the named configuration environment value as a tuple of imported objects.\n\n        :param str name: The name of the configuration value, as defined on this object or in the environment.\n        :param Any default: A default value, already a tuple of objects.\n        \"\"\"\n        paths = self.get_tuple(name, default=default)\n        return tuple(import_object(path) for path in paths)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_bool","title":"<code>as_bool(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a boolean value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a boolean.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_bool(self, name: str, default: Union[bool, TUndefined] = UNDEFINED) -&gt; bool:\n    \"\"\"Return the named configuration environment value as a boolean value.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a boolean.\n    \"\"\"\n    return self.get(name, default=default, caster=bool)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_bool_tuple","title":"<code>as_bool_tuple(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a tuple of boolean values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a tuple of booleans.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_bool_tuple(self, name: str, default: Union[tuple[bool], TUndefined] = UNDEFINED) -&gt; tuple[bool]:\n    \"\"\"Return the named configuration environment value as a tuple of boolean values.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a tuple of booleans.\n    \"\"\"\n    return self.get_tuple(name, default=default, caster=tuple[bool])\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_float","title":"<code>as_float(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a float.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a float.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_float(self, name: str, default: Union[float, TUndefined] = UNDEFINED) -&gt; float:\n    \"\"\"Return the named configuration environment value as a float.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a float.\n    \"\"\"\n    return self.get(name, default=default, caster=float)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_float_tuple","title":"<code>as_float_tuple(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a tuple of floats.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a tuple of floats.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_float_tuple(self, name: str, default: Union[tuple[float], TUndefined] = UNDEFINED) -&gt; tuple[float]:\n    \"\"\"Return the named configuration environment value as a tuple of floats.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a tuple of floats.\n    \"\"\"\n    return self.get_tuple(name, default=default, caster=tuple[float])\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_int","title":"<code>as_int(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as an int.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already an int.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_int(self, name: str, default: Union[int, TUndefined] = UNDEFINED) -&gt; int:\n    \"\"\"Return the named configuration environment value as an int.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already an int.\n    \"\"\"\n    return self.get(name, default=default, caster=int)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_int_tuple","title":"<code>as_int_tuple(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a tuple of ints.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a tuple of ints.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_int_tuple(self, name: str, default: Union[tuple[int], TUndefined] = UNDEFINED) -&gt; tuple[int]:\n    \"\"\"Return the named configuration environment value as a tuple of ints.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a tuple of ints.\n    \"\"\"\n    return self.get_tuple(name, default=default, caster=tuple[int])\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_object_import","title":"<code>as_object_import(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as an imported object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already an object.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_object_import(self, name: str, default: Union[Any, TUndefined] = UNDEFINED) -&gt; Any:\n    \"\"\"Return the named configuration environment value as an imported object.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already an object.\n    \"\"\"\n    path = self.get(name, default=default)\n    return import_object(path)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_object_import_tuple","title":"<code>as_object_import_tuple(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a tuple of imported objects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a tuple of objects.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_object_import_tuple(self, name: str, default: Union[tuple[Any], TUndefined] = UNDEFINED):\n    \"\"\"Return the named configuration environment value as a tuple of imported objects.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a tuple of objects.\n    \"\"\"\n    paths = self.get_tuple(name, default=default)\n    return tuple(import_object(path) for path in paths)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_package_import","title":"<code>as_package_import(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as an imported module.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a module.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_package_import(self, name: str, default: Union[Any, TUndefined] = UNDEFINED) -&gt; Any:\n    \"\"\"Return the named configuration environment value as an imported module.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a module.\n    \"\"\"\n    path = self.get(name, default=default)\n    return importlib.import_module(path)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_package_import_tuple","title":"<code>as_package_import_tuple(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a tuple of imported modules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a tuple of modules.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_package_import_tuple(self, name: str, default: Union[tuple[Any], TUndefined] = UNDEFINED) -&gt; tuple[Any]:\n    \"\"\"Return the named configuration environment value as a tuple of imported modules.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a tuple of modules.\n    \"\"\"\n    paths = self.get_tuple(name, default=default)\n    return tuple(importlib.import_module(path) for path in paths)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_path","title":"<code>as_path(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a Path.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a Path.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_path(self, name: str, default: Union[Path, TUndefined] = UNDEFINED) -&gt; Path:\n    \"\"\"Return the named configuration environment value as a Path.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a Path.\n    \"\"\"\n    return self.get(name, default=default, caster=Path)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_path_tuple","title":"<code>as_path_tuple(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a tuple of Paths.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a tuple of Paths.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_path_tuple(self, name: str, default: Union[tuple[float], TUndefined] = UNDEFINED) -&gt; tuple[Path]:\n    \"\"\"Return the named configuration environment value as a tuple of Paths.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a tuple of Paths.\n    \"\"\"\n    return self.get(name, default=default, caster=tuple[Path])\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_secret","title":"<code>as_secret(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a Secret string.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a Secret.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_secret(self, name: str, default: Secret = UNDEFINED) -&gt; Secret:\n    \"\"\"Return the named configuration environment value as a Secret string.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a Secret.\n    \"\"\"\n    return self.get(name, default=default, caster=Secret)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.as_secret_tuple","title":"<code>as_secret_tuple(name, default=UNDEFINED)</code>","text":"<p>Return the named configuration environment value as a sequence of Secret strings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already a tuple of Secrets.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def as_secret_tuple(self, name: str, default: Union[tuple[Secret], TUndefined] = UNDEFINED) -&gt; tuple[Secret]:\n    \"\"\"Return the named configuration environment value as a sequence of Secret strings.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already a tuple of Secrets.\n    \"\"\"\n    return self.get_tuple(name, default=default, caster=tuple[Secret])\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.asdict","title":"<code>asdict(keys=())</code>","text":"<p>Return a dictionary with the defined settings</p> Source code in <code>src/convoke/configs.py</code> <pre><code>def asdict(self, keys=()) -&gt; dict:\n    \"\"\"Return a dictionary with the defined settings\"\"\"\n    if keys:\n        return fn.project(dc.asdict(self), keys)\n    else:\n        return dc.asdict(self)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.from_config","title":"<code>from_config(config)</code>  <code>classmethod</code>","text":"<p>Derive an instance of this config class from another configuration.</p> <p>This is really only useful if the passed configuration has overridden (non-environment-derived) values.</p> Source code in <code>src/convoke/configs.py</code> <pre><code>@classmethod\ndef from_config(cls: Type[T], config: \"BaseConfig\") -&gt; T:\n    \"\"\"Derive an instance of this config class from another configuration.\n\n    This is really only useful if the passed configuration has\n    overridden (non-environment-derived) values.\n\n    \"\"\"\n    valid_params = set(inspect.signature(cls).parameters)\n    kwargs = {k: v for k, v in dc.asdict(config).items() if k in valid_params}\n    return cls(**kwargs)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.gather_settings","title":"<code>gather_settings()</code>  <code>classmethod</code>","text":"<p>Gather settings from all loaded configurations.</p> Source code in <code>src/convoke/configs.py</code> <pre><code>@classmethod\ndef gather_settings(cls) -&gt; dict:\n    \"\"\"Gather settings from all loaded configurations.\"\"\"\n    base = BaseConfig.report_settings()\n    base_settings = set(base[\"settings\"].keys())\n    all_settings = {f\"{BaseConfig.__module__}.{BaseConfig.__name__}\": base}\n    for config in cls.plugins_by_name.values():\n        settings = config.report_settings()\n        all_settings[f\"{config.__module__}.{config.__name__}\"] = {\n            \"doc\": settings[\"doc\"],\n            \"settings\": omit(settings[\"settings\"], base_settings),\n        }\n\n    return all_settings\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.get","title":"<code>get(name, default=UNDEFINED, caster=UNDEFINED)</code>","text":"<p>Return the named configuration environment value, optionally casting it as specified.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already the expected type.</p> <code>UNDEFINED</code> <code>caster</code> <code>Type</code> <p>A type to cast the string value to, if any.</p> <code>UNDEFINED</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def get(self, name: str, default: Any = UNDEFINED, caster: Union[Type, TUndefined] = UNDEFINED) -&gt; Any:\n    \"\"\"Return the named configuration environment value, optionally casting it as specified.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already the expected type.\n    :param Type caster: A type to cast the string value to, if any.\n    \"\"\"\n    if caster is UNDEFINED:\n        caster = identity\n    else:\n        caster = get_casting_type(name, caster)\n    try:\n        value = self[name]\n    except KeyError:\n        if default is UNDEFINED:\n            raise\n        else:\n            value = default\n\n    return caster(value)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.get_tuple","title":"<code>get_tuple(name, default=UNDEFINED, caster=tuple[str])</code>","text":"<p>Return the named configuration environment value as a sequence, optionally casting internal values as specified.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value, as defined on this object or in the environment.</p> required <code>default</code> <code>Any</code> <p>A default value, already the expected type.</p> <code>UNDEFINED</code> <code>caster</code> <code>Type</code> <p>A type to cast the internal string values to, if any.</p> <code>tuple[str]</code> Source code in <code>src/convoke/configs.py</code> <pre><code>def get_tuple(\n    self, name: str, default: Union[tuple[Any], TUndefined] = UNDEFINED, caster: Type = tuple[str]\n) -&gt; tuple[Any]:\n    \"\"\"Return the named configuration environment value as a sequence, optionally casting internal values as specified.\n\n    :param str name: The name of the configuration value, as defined on this object or in the environment.\n    :param Any default: A default value, already the expected type.\n    :param Type caster: A type to cast the internal string values to, if any.\n    \"\"\"\n    return self.get(name, default=default, caster=caster)\n</code></pre>"},{"location":"reference/configs/#convoke.configs.BaseConfig.report_settings","title":"<code>report_settings()</code>  <code>classmethod</code>","text":"<p>Prepare a datastructure reporting on this configuration class's settings.</p> Source code in <code>src/convoke/configs.py</code> <pre><code>@classmethod\ndef report_settings(cls) -&gt; dict:\n    \"\"\"Prepare a datastructure reporting on this configuration class's settings.\"\"\"\n    return {\n        \"doc\": format_object_docstring(cls),\n        \"settings\": {\n            fd.name: {\n                \"type\": fd.type,\n                \"default\": (\n                    UNDEFINED\n                    if (default := getattr(fd, \"__config_default__\", dc.MISSING)) is dc.MISSING\n                    else default\n                ),\n                \"doc\": getattr(fd, \"__doc__\", \"\"),\n            }\n            for fd in dc.fields(cls)\n        },\n    }\n</code></pre>"},{"location":"reference/mountpoints/","title":"<code>convoke.mountpoints</code>","text":"<p>Tools for registering Base plugins</p>"},{"location":"reference/mountpoints/#convokemountpointsmountpoint","title":"convoke.mountpoints.Mountpoint","text":"<p>A Mountpoint, subclassed, provides a place to register objects for a particular use.</p> <p>This registration collaborates with <code>Base</code>.</p> Source code in <code>src/convoke/mountpoints.py</code> <pre><code>@dataclass\nclass Mountpoint:\n    \"\"\"A Mountpoint, subclassed, provides a place to register objects for a particular use.\n\n    This registration collaborates with [`Base`][convoke.bases.Base].\n    \"\"\"\n\n    mounted: list = field(default_factory=list)\n\n    _mountpoints: ClassVar[list[Type[Mountpoint]]] = []\n\n    def __init_subclass__(cls):\n        cls._mountpoints.append(cls)\n        cls.registry = []\n\n    @classmethod\n    def register(cls, func):\n        \"\"\"Register the given function for use with the mountpoint.\n\n        This registration collaborates with [`Base`][convoke.bases.Base].\n        \"\"\"\n        mp = getattr(func, \"__mountpoints__\", [])\n        mp.append(cls)\n        func.__mountpoints__ = mp\n        return func\n\n    def mount(self, func):\n        \"\"\"Mount a registered function on this instance.\"\"\"\n        self.mounted.append(func)\n</code></pre>"},{"location":"reference/mountpoints/#convoke.mountpoints.Mountpoint.mount","title":"<code>mount(func)</code>","text":"<p>Mount a registered function on this instance.</p> Source code in <code>src/convoke/mountpoints.py</code> <pre><code>def mount(self, func):\n    \"\"\"Mount a registered function on this instance.\"\"\"\n    self.mounted.append(func)\n</code></pre>"},{"location":"reference/mountpoints/#convoke.mountpoints.Mountpoint.register","title":"<code>register(func)</code>  <code>classmethod</code>","text":"<p>Register the given function for use with the mountpoint.</p> <p>This registration collaborates with <code>Base</code>.</p> Source code in <code>src/convoke/mountpoints.py</code> <pre><code>@classmethod\ndef register(cls, func):\n    \"\"\"Register the given function for use with the mountpoint.\n\n    This registration collaborates with [`Base`][convoke.bases.Base].\n    \"\"\"\n    mp = getattr(func, \"__mountpoints__\", [])\n    mp.append(cls)\n    func.__mountpoints__ = mp\n    return func\n</code></pre>"},{"location":"reference/signals/","title":"<code>convoke.signals</code>","text":"<p>Utilities for managing async signals and signal handlers</p>"},{"location":"reference/signals/#convokesignalssignal","title":"convoke.signals.Signal","text":"<p>A Signal provides a typed interface for sending messages through the current HQ.</p> <p>To define a signal, subclass and provide a member class <code>Message</code>, which defines the keyword arguments that may be sent through the signal.</p> Source code in <code>src/convoke/signals.py</code> <pre><code>class Signal:\n    \"\"\"A Signal provides a typed interface for sending messages through the current HQ.\n\n    To define a signal, subclass and provide a member class\n    [`Message`][convoke.signals.Signal.Message], which defines the keyword\n    arguments that may be sent through the signal.\n    \"\"\"\n\n    @dataclass\n    class Message:\n        \"\"\"The default message type for signals.\n\n        Define your own Message dataclass on each Signal for type-safe signals.\n\n        :param str value: a simple string to send as part of the message\n        \"\"\"\n\n        value: str\n\n    @classmethod\n    def connect(cls, receiver: Receiver, using: HQ | None = None):\n        \"\"\"Connect a callable to this signal.\n\n        :param Receiver receiver: a callable that accepts a single argument of type `Signal.Message`\n        :param HQ using: the [`HQ`][convoke.bases.HQ] instance to connect on (defaults to `HQ.current_hq`)\n        \"\"\"\n        if using is None:\n            using = current_hq.get()\n        using.connect_signal_receiver(cls, receiver)\n\n    @classmethod\n    def disconnect(cls, receiver: Receiver, using: HQ | None = None):\n        \"\"\"Disconnect a previously-connected callable.\n\n        :param Receiver receiver: a Receiver previously connected via this HQ\n        :param HQ using: the [`HQ`][convoke.bases.HQ] instance to send to (defaults to `HQ.current_hq`)\n        \"\"\"\n        if using is None:\n            using = current_hq.get()\n        using.disconnect_signal_receiver(cls, receiver)\n\n    @classmethod\n    async def send(cls, *, using: HQ | None = None, **kwargs):\n        \"\"\"Send a message over this Signal.\n\n        Messages are sent asynchronously. Do not depend on side\n        effects to happen immediately.\n\n        :param HQ using: the [`HQ`][convoke.bases.HQ] instance to send to (defaults to `HQ.current_hq`)\n        :param **kwargs: the keyword arguments to construct the `Signal.Message` with.\n\n        \"\"\"\n        msg = cls.Message(**kwargs)\n        if using is None:\n            using = current_hq.get()\n        await using.send_signal(cls, msg)\n</code></pre>"},{"location":"reference/signals/#convoke.signals.Signal.Message","title":"<code>Message</code>  <code>dataclass</code>","text":"<p>The default message type for signals.</p> <p>Define your own Message dataclass on each Signal for type-safe signals.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>a simple string to send as part of the message</p> required Source code in <code>src/convoke/signals.py</code> <pre><code>@dataclass\nclass Message:\n    \"\"\"The default message type for signals.\n\n    Define your own Message dataclass on each Signal for type-safe signals.\n\n    :param str value: a simple string to send as part of the message\n    \"\"\"\n\n    value: str\n</code></pre>"},{"location":"reference/signals/#convoke.signals.Signal.connect","title":"<code>connect(receiver, using=None)</code>  <code>classmethod</code>","text":"<p>Connect a callable to this signal.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>Receiver</code> <p>a callable that accepts a single argument of type <code>Signal.Message</code></p> required <code>using</code> <code>HQ</code> <p>the <code>HQ</code> instance to connect on (defaults to <code>HQ.current_hq</code>)</p> <code>None</code> Source code in <code>src/convoke/signals.py</code> <pre><code>@classmethod\ndef connect(cls, receiver: Receiver, using: HQ | None = None):\n    \"\"\"Connect a callable to this signal.\n\n    :param Receiver receiver: a callable that accepts a single argument of type `Signal.Message`\n    :param HQ using: the [`HQ`][convoke.bases.HQ] instance to connect on (defaults to `HQ.current_hq`)\n    \"\"\"\n    if using is None:\n        using = current_hq.get()\n    using.connect_signal_receiver(cls, receiver)\n</code></pre>"},{"location":"reference/signals/#convoke.signals.Signal.disconnect","title":"<code>disconnect(receiver, using=None)</code>  <code>classmethod</code>","text":"<p>Disconnect a previously-connected callable.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>Receiver</code> <p>a Receiver previously connected via this HQ</p> required <code>using</code> <code>HQ</code> <p>the <code>HQ</code> instance to send to (defaults to <code>HQ.current_hq</code>)</p> <code>None</code> Source code in <code>src/convoke/signals.py</code> <pre><code>@classmethod\ndef disconnect(cls, receiver: Receiver, using: HQ | None = None):\n    \"\"\"Disconnect a previously-connected callable.\n\n    :param Receiver receiver: a Receiver previously connected via this HQ\n    :param HQ using: the [`HQ`][convoke.bases.HQ] instance to send to (defaults to `HQ.current_hq`)\n    \"\"\"\n    if using is None:\n        using = current_hq.get()\n    using.disconnect_signal_receiver(cls, receiver)\n</code></pre>"},{"location":"reference/signals/#convoke.signals.Signal.send","title":"<code>send(*, using=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Send a message over this Signal.</p> <p>Messages are sent asynchronously. Do not depend on side effects to happen immediately.</p> <p>Parameters:</p> Name Type Description Default <code>using</code> <code>HQ</code> <p>the <code>HQ</code> instance to send to (defaults to <code>HQ.current_hq</code>)</p> <code>None</code> <code>**kwargs</code> <p>the keyword arguments to construct the <code>Signal.Message</code> with.</p> <code>{}</code> Source code in <code>src/convoke/signals.py</code> <pre><code>@classmethod\nasync def send(cls, *, using: HQ | None = None, **kwargs):\n    \"\"\"Send a message over this Signal.\n\n    Messages are sent asynchronously. Do not depend on side\n    effects to happen immediately.\n\n    :param HQ using: the [`HQ`][convoke.bases.HQ] instance to send to (defaults to `HQ.current_hq`)\n    :param **kwargs: the keyword arguments to construct the `Signal.Message` with.\n\n    \"\"\"\n    msg = cls.Message(**kwargs)\n    if using is None:\n        using = current_hq.get()\n    await using.send_signal(cls, msg)\n</code></pre>"},{"location":"tutorials/","title":"Tutorial Index","text":"<ul> <li>Configuring your application with Convoke</li> </ul>"},{"location":"tutorials/configuring/","title":"Tutorial: Configuring Your Application","text":"<p>In this tutorial, we'll see how to use <code>convoke</code> to configure a simple Starlette web application.</p> <p>We'll start with a very simple Starlette web app:</p> <pre><code># app.py\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\ntemplates = Jinja2Templates(directory='templates')\n\n\nasync def homepage(request):\n    return templates.TemplateResponse(\n        \"index.html\",\n        {\"request\": request, \"DEBUG\": request.app.debug}\n    )\n\n\ndef create_app():\n    return Starlette(debug=True, routes=[\n        Route('/', homepage),\n    ])\n</code></pre>"},{"location":"tutorials/configuring/#built-in-configuration-settings","title":"Built-in configuration settings","text":"<p>Now, of course, we don't want to always be in debug mode. Let's add a configuration by subclassing <code>convoke.configs.BaseConfig</code>:</p> <pre><code># app.py\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom convoke.configs import BaseConfig, env_field\n\n# ...\n\nclass WebAppConfig(BaseConfig):\n    \"\"\"Configuration for our web application.\"\"\"\n\n\ndef create_app():\n    config = WebAppConfig()\n\n    return Starlette(debug=config.DEBUG, routes=[\n        Route('/', homepage),\n    ])\n\n</code></pre> <p>Every instance of <code>BaseConfig</code> has two built-in settings: <code>DEBUG</code> and <code>TESTING</code>, both booleans with a default value of <code>False</code>. So, if we run our application, it will default to production mode:</p> <pre><code>$ uvicorn --factory app.create_app\n</code></pre> <p>But if we set the environment variable <code>DEBUG=True</code>, it will run in development mode:</p> <pre><code>$ DEBUG=True uvicorn --factory app.create_app\n</code></pre> <p><code>DEBUG=true</code> and <code>DEBUG=TRUE</code> would also work, but <code>tRuE</code> would not. Likewise, with equivalent cases of <code>DEBUG=False</code>.</p>"},{"location":"tutorials/configuring/#custom-configuration-settings","title":"Custom configuration settings","text":"<p>Now, to improve our application, we'll want our users to be able to login, and for that, we'll need sessions:</p> <pre><code># app.py\nfrom starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.sessions import SessionMiddleware\n# ...\n\ndef create_app():\n    config = WebAppConfig()\n\n    return Starlette(\n        debug=config.DEBUG,\n        routes=[\n            Route('/', homepage),\n        ],\n        middleware=[\n            Middleware(\n                SessionMiddleware,\n                secret_key=\"supers3kr1t\",\n                https_only=not config.DEBUG)\n        ],\n    )\n</code></pre> <p>We see how the configuration is already making our lives easier: in production we want secure sessions, which requires HTTPS, but in development we don't want to bother with HTTPS, so we use <code>https_only=not config.DEBUG</code> to only require HTTPS in production.</p>"},{"location":"tutorials/configuring/#protecting-secrets","title":"Protecting secrets","text":"<p>However, we have another problem: our secret key is stored in plain text in our Python source. Anyone who can read this file can discover our secret and hack our users! What to do?</p> <p>Let's move our secret key to the environment:</p> <pre><code># app.py\n# ...\n\nclass WebAppConfig(BaseConfig):\n    \"\"\"Configuration for our web application.\"\"\"\n\n    SECRET_KEY: str = env_field()\n\n\ndef create_app():\n    config = WebAppConfig()\n\n    return Starlette(\n        # ...\n        middleware=[\n            Middleware(\n                SessionMiddleware,\n                secret_key=config.SECRET_KEY,\n                https_only=not config.DEBUG)\n        ],\n    )\n\n</code></pre> <p>We use all caps <code>SECRET_KEY</code> by convention, and the corresponding environment variable:</p> <pre><code>$ DEBUG=True SECRET_KEY=\"supers3kr1t\"  uvicorn --factory app.create_app\n</code></pre> <p>Now, one problem is that if we ever print our configuration to the console, we get our secret in plain text again:</p> <pre><code>$ DEBUG=True SECRET_KEY=\"supers3kr1t\"  python\n&gt;&gt;&gt; from app import WebAppConfig\n\n&gt;&gt;&gt; print(WebAppConfig())\nWebAppConfig(DEBUG=True, TESTING=False, SECRET_KEY='supers3kr1t')\n</code></pre> <p>Let's fix that by using the <code>Secret</code> type:</p> <pre><code># app.py\n# ...\nfrom convoke.configs import BaseConfig, env_field, Secret\n# ...\n\nclass WebAppConfig(BaseConfig):\n    \"\"\"Configuration for our web application.\"\"\"\n\n    SECRET_KEY: Secret = env_field()\n\n</code></pre> <p>Now, when we print to the console, our secret is safe:</p> <pre><code>$ DEBUG=True SECRET_KEY=\"supers3kr1t\"  python\n&gt;&gt;&gt; from app import WebAppConfig\n\n&gt;&gt;&gt; print(WebAppConfig())\nWebAppConfig(DEBUG=True, TESTING=False, SECRET_KEY=Secret('**********'))\n</code></pre> <p>But when we use the secret as a string, we get the plain-text value:</p> <pre><code>&gt;&gt;&gt; str(WebAppConfig().SECRET_KEY)\n'supers3kr1t'\n</code></pre>"},{"location":"tutorials/configuring/#other-configuration-field-types","title":"Other configuration field types","text":"<p>Since we're considering security, let's consider our session age. Starlette's default session age is 2 weeks (1,209,600 seconds), but say that for our application, we require that a user session must be refreshed by authentication every 24 hours (86,400 seconds). As a business policy, this may change in the future, so let's make it a configurable value:</p> <pre><code># app.py\n# ...\nfrom convoke.configs import BaseConfig, env_field, Secret\n# ...\n\nclass WebAppConfig(BaseConfig):\n    \"\"\"Configuration for our web application.\"\"\"\n\n    SECRET_KEY: Secret = env_field()\n    SESSION_COOKIE_MAX_AGE: int = env_field(default=86_400)\n\n\ndef create_app():\n    config = WebAppConfig()\n\n    return Starlette(\n        # ...\n        middleware=[\n            Middleware(\n                SessionMiddleware,\n                secret_key=config.SECRET_KEY,\n                https_only=not config.DEBUG,\n                max_age=config.SESSION_COOKIE_MAX_AGE,\n            ),\n        ],\n    )\n\n</code></pre> <p>By annotating the type of the configuration field, we tell <code>convoke</code> how to parse the environment string. This works for floats and booleans too:</p> <pre><code>class MyConfig(BaseConfig):\n    VALUE_OF_PI: float = env_field(default=3.14)\n    USE_ANTIGRAVITY: bool = env_field(default=False)\n</code></pre>"},{"location":"tutorials/configuring/#configuration-fields-with-multiple-values","title":"Configuration fields with multiple values","text":"<p>Now, to really make sure our application is secure, let's configure Starlette's <code>TrustedHostMiddleware</code>:</p> <pre><code># app.py\n# ...\nfrom starlette.middleware.trustedhost import TrustedHostMiddleware\n# ...\n\nclass WebAppConfig(BaseConfig):\n    \"\"\"Configuration for our web application.\"\"\"\n\n    SECRET_KEY: Secret = env_field()\n    SESSION_COOKIE_MAX_AGE: int = env_field(default=86_400)\n    ALLOWED_HOSTS: tuple[str] = env_field(default=('127.0.0.1', 'localhost'))\n\n\ndef create_app():\n    config = WebAppConfig()\n\n    return Starlette(\n        # ...\n        middleware=[\n            # ...\n            Middleware(\n                TrustedHostMiddleware,\n                allowed_hosts=config.ALLOWED_HOSTS,\n            ),\n        ],\n    )\n</code></pre> <p>By using the type annotation <code>tuple[str]</code>, we tell <code>convoke</code> to parse the value as a comma-separated list of strings, resulting in a tuple of strings:</p> <pre><code>$ DEBUG=True SECRET_KEY=\"supers3kr1t\" ALLOWED_HOSTS=\"example.com,*.example.com\"  uvicorn --factory app.create_app\n</code></pre> <p>We could also use <code>tuple[int]</code> for a setting that uses a sequence of integers, etc.</p>"},{"location":"tutorials/configuring/#prefer-immutability","title":"Prefer immutability","text":"<p>For that matter, we could also use <code>ALLOWED_HOSTS: list[str]</code> give us a list of strings instead of a tuple, but Config instances are immutable, and it's best to use immutable types for configuration values as well.</p>"},{"location":"tutorials/configuring/#generating-a-env-file","title":"Generating a .env file","text":"<p>As we've added more configuration values, our <code>uvicorn</code> invocation has been getting longer and longer. Web applications can have tens if not hundreds of configuration values, and we don't want to type these out every time we start up the dev server! Let's fix that:</p> <pre><code># app.py\n# ...\nfrom convoke.configs import BaseConfig, env_field, generate_dot_env, Secret\n# ...\n\nif __name__ == \"__main__\":\n    print(generate_dot_env(BaseConfig.gather_settings()))\n</code></pre> <p>Then, in the shell:</p> <pre><code>$ python app.py &gt; .env\n$ cat .env\n################################\n## convoke.configs.BaseConfig ##\n################################\n##\n## Base settings common to all configurations\n\n# ------------------\n# -- DEBUG (bool) --\n# ------------------\n#\n# Development mode?\n\nDEBUG=\"False\"\n\n# --------------------\n# -- TESTING (bool) --\n# --------------------\n#\n# Testing mode?\n\nTESTING=\"False\"\n\n\n###########################\n## __main__.WebAppConfig ##\n###########################\n##\n## Configuration for our web application.\n\n# ---------------------------------------\n# -- SECRET_KEY (Secret) **Required!** --\n# ---------------------------------------\n\nSECRET_KEY=\"6BIW_mb496YHiptQ1E4WVm-7b_YBW1zQFqZnBKmcsDpTlb1Qb8uZ8w\"\n\n# ---------------------------\n# -- SESSION_COOKIE_MAX_AGE (int) --\n# ---------------------------\n\nSESSION_COOKIE_MAX_AGE=\"86400\"\n\n# ---------------------------\n# -- ALLOWED_HOSTS (tuple) --\n# ---------------------------\n\nALLOWED_HOSTS=\"127.0.0.1,localhost\"\n</code></pre> <p>A few things to note here:</p> <ul> <li>Default values are included</li> <li>Secrets are assigned a securely-generated value</li> <li>Configuration values have documentation!</li> </ul>"},{"location":"tutorials/configuring/#documenting-configuration-values","title":"Documenting configuration values","text":"<p>Let's add some documentation to our config values:</p> <pre><code># app.py\n# ...\n\nclass WebAppConfig(BaseConfig):\n    \"\"\"Configuration for our web application.\"\"\"\n\n    SECRET_KEY: Secret = env_field(\n        doc=\"\"\"\n            Secret used to cryptographically sign session cookies.\n\n            This should be set to a unique, unpredictable value and kept safe\n            from prying eyes.\n        \"\"\",\n    )\n    SESSION_COOKIE_MAX_AGE: int = env_field(\n        default=86_400,\n        doc=\"\"\"\n            The maximum age of session cookies, in seconds.\n\n            Defaults to 24 hours.\n        \"\"\",\n    )\n    ALLOWED_HOSTS: tuple[str] = env_field(\n        default=('127.0.0.1', 'localhost'),\n        doc=\"\"\"\n            A list of strings representing the host/domain names that this site can serve.\n        \"\"\"\n    )\n</code></pre> <p>And now, if we generate a <code>.env</code> file again, we see our new documentation:</p> <pre><code>$ python app.py\n# ...\n###########################\n## __main__.WebAppConfig ##\n###########################\n##\n## Configuration for our web application.\n\n# ---------------------------------------\n# -- SECRET_KEY (Secret) **Required!** --\n# ---------------------------------------\n#\n# Secret used to cryptographically sign session cookies.\n#\n# This should be set to a unique, unpredictable value and kept safe from\n# prying eyes.\n\nSECRET_KEY=\"6rlnXtlxeggkgaG1Y4EsEitfRTGjUxu8zbdtZ8GpwfbwCmi0J2Tb3w\"\n\n# ----------------------------------\n# -- SESSION_COOKIE_MAX_AGE (int) --\n# ----------------------------------\n#\n# The maximum age of session cookies, in seconds.\n#\n# Defaults to 24 hours.\n\nSESSION_COOKIE_MAX_AGE=\"86400\"\n\n# ---------------------------\n# -- ALLOWED_HOSTS (tuple) --\n# ---------------------------\n#\n# A list of strings representing the host/domain names that this site can serve.\n\nALLOWED_HOSTS=\"127.0.0.1,localhost\"\n</code></pre>"},{"location":"tutorials/configuring/#conclusion","title":"Conclusion","text":"<p>With that, you should now understand the basics of configuring a Starlette application with <code>convoke</code>, including how to keep secrets safe, and how to document your settings.</p>"}]}